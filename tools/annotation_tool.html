<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BNBUSDT Kçº¿æ•°æ®æ ‡æ³¨å·¥å…·</title>
    <!-- å¼•å…¥ ECharts - ä½¿ç”¨å¤šä¸ªCDNå¤‡ç”¨ -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"
            onerror="this.onerror=null; this.src='https://unpkg.com/echarts@5.4.3/dist/echarts.min.js'"></script>
    <!-- å¼•å…¥ JSZip - ç”¨äºå¯¼å‡ºå›¾åƒZIP -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"
            onerror="this.onerror=null; this.src='https://unpkg.com/jszip@3.10.1/dist/jszip.min.js'"></script>
    <script>
        // æ£€æŸ¥EChartsæ˜¯å¦åŠ è½½æˆåŠŸ
        window.addEventListener('DOMContentLoaded', function() {
            if (typeof echarts === 'undefined') {
                console.error('âŒ EChartsåº“åŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ç½‘ç»œæˆ–å…³é—­æµè§ˆå™¨çš„è·Ÿè¸ªä¿æŠ¤ã€‚');
                alert('âš ï¸ EChartsåº“åŠ è½½å¤±è´¥ï¼\n\nè¯·å°è¯•ï¼š\n1. å…³é—­æµè§ˆå™¨çš„è·Ÿè¸ªä¿æŠ¤ï¼ˆåœ°å€æ æ—çš„ç›¾ç‰Œå›¾æ ‡ï¼‰\n2. åˆ·æ–°é¡µé¢\n3. æˆ–ä½¿ç”¨å…¶ä»–æµè§ˆå™¨ï¼ˆChrome/Edgeï¼‰');
            } else {
                console.log('âœ… EChartsåº“åŠ è½½æˆåŠŸï¼Œç‰ˆæœ¬:', echarts.version);
            }
        });
    </script>
    <style>
        /* å…¨å±€æ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }

        /* æ ‡é¢˜åŒº */
        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #667eea;
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 14px;
        }

        /* æ–‡ä»¶ä¸Šä¼ åŒº */
        .upload-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px dashed #ccc;
        }

        .upload-section input[type="file"] {
            display: none;
        }

        .upload-btn {
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .file-info {
            margin-top: 10px;
            color: #666;
            font-size: 14px;
        }

        /* Kçº¿å±•ç¤ºåŒº */
        .kline-display-section {
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-radius: 10px;
            border: 2px solid #667eea;
        }

        .section-title {
            color: #667eea;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
        }

        /* Kçº¿å›¾è¡¨å®¹å™¨ */
        #klineChart {
            width: 100%;
            height: 600px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        /* ä¸‰å›¾å±•ç¤ºåŒº */
        .canvas-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .canvas-wrapper {
            flex: 1;
            text-align: center;
        }

        .canvas-wrapper.main {
            flex: 1.5;
        }

        .canvas-wrapper canvas {
            border: 3px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            height: auto;
        }

        .canvas-wrapper.main canvas {
            border-width: 4px;
        }

        .canvas-wrapper canvas:hover {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .canvas-label {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }

        /* æ ‡æ³¨æŒ‰é’®åŒº */
        .control-section {
            margin-bottom: 30px;
        }

        .button-group {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .label-buttons {
            display: flex;
            gap: 15px;
        }

        .nav-buttons {
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 15px 40px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-up {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-down {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .btn-fluctuation {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-nav {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-save {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
            font-weight: 700;
            box-shadow: 0 4px 8px rgba(250, 112, 154, 0.4);
        }

        .btn-save:hover {
            box-shadow: 0 6px 16px rgba(250, 112, 154, 0.6);
        }

        /* è¿›åº¦ç»Ÿè®¡åŒº */
        .progress-section {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .progress-info {
            text-align: center;
            margin-bottom: 15px;
        }

        .progress-info h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }

        .statistics {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stat-item {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .stat-item .label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-item .value {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }

        .stat-item.up .value {
            color: #11998e;
        }

        .stat-item.down .value {
            color: #eb3349;
        }

        .stat-item.fluctuation .value {
            color: #f5576c;
        }

        /* éšè—çŠ¶æ€ */
        .hidden {
            display: none;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1200px) {
            .canvas-container {
                flex-direction: column;
            }

            .canvas-wrapper {
                width: 100%;
            }
        }

        /* é”®ç›˜æç¤º */
        .keyboard-hint {
            text-align: center;
            margin-top: 20px;
            color: #999;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- æ ‡é¢˜åŒº -->
        <div class="header">
            <h1>ğŸ“Š BNBUSDT Kçº¿æ•°æ®æ ‡æ³¨å·¥å…·</h1>
            <p>æ”¯æŒ24æ ¹Kçº¿çª—å£æ»‘åŠ¨æ ‡æ³¨ï¼Œå®æ—¶ä¿å­˜ï¼Œé”®ç›˜å¿«æ·æ“ä½œ</p>
        </div>

        <!-- æ–‡ä»¶ä¸Šä¼ åŒº -->
        <div class="upload-section">
            <input type="file" id="fileInput" accept=".csv">
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                ğŸ“ é€‰æ‹©CSVæ–‡ä»¶
            </button>
            <div class="file-info" id="fileInfo">è¯·ä¸Šä¼ åŒ…å« time (æˆ– timestamp), open, high, low, close, volume å­—æ®µçš„CSVæ–‡ä»¶</div>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºï¼ˆåˆå§‹éšè—ï¼‰ -->
        <div id="mainContent" class="hidden">
            <!-- Kçº¿æ•°æ®å±•ç¤ºåŒº -->
            <div class="kline-display-section">
                <h3 class="section-title">ğŸ“ˆ Kçº¿æ•°æ®å±•ç¤ºï¼ˆå…¨å±€è§†å›¾ - é»„è‰²åŒºåŸŸä¸ºå½“å‰æ ‡æ³¨çª—å£ï¼‰</h3>
                <div id="klineChart"></div>
            </div>

            <!-- å½’ä¸€åŒ–ä¸‰å›¾å±•ç¤ºåŒº -->
            <h3 class="section-title">ğŸ¯ å½’ä¸€åŒ–Kçº¿æ ‡æ³¨åŒº</h3>
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="canvasPrev" width="400" height="300"></canvas>
                    <div class="canvas-label">â¬…ï¸ ä¸Šä¸€å¼ </div>
                </div>
                <div class="canvas-wrapper main">
                    <canvas id="canvasCurrent" width="600" height="400"></canvas>
                    <div class="canvas-label">ğŸ¯ å½“å‰æ ‡æ³¨</div>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="canvasNext" width="400" height="300"></canvas>
                    <div class="canvas-label">ä¸‹ä¸€å¼  â¡ï¸</div>
                </div>
            </div>

            <!-- æ§åˆ¶æŒ‰é’®åŒº -->
            <div class="control-section">
                <div class="button-group">
                    <div class="label-buttons">
                        <button class="btn btn-up" onclick="app.setLabel('up')">
                            ğŸ“ˆ ä¸Šæ¶¨ (1)
                        </button>
                        <button class="btn btn-down" onclick="app.setLabel('down')">
                            ğŸ“‰ ä¸‹è·Œ (2)
                        </button>
                        <button class="btn btn-fluctuation" onclick="app.setLabel('fluctuation')">
                            ğŸ“Š æ³¢åŠ¨ (3)
                        </button>
                    </div>
                    <div class="nav-buttons">
                        <button class="btn btn-nav" id="btnPrev" onclick="app.prevPage()">
                            â¬…ï¸ ä¸Šä¸€å¼  (â†)
                        </button>
                        <button class="btn btn-nav" id="btnNext" onclick="app.nextPage()">
                            ä¸‹ä¸€å¼  â¡ï¸ (â†’)
                        </button>
                    </div>
                </div>
                <div class="button-group">
                    <button class="btn btn-save" onclick="app.saveToCSV()">
                        ğŸ’¾ ä¿å­˜çª—å£æ•°æ® (S)
                    </button>
                    <button class="btn btn-save" onclick="app.exportLabeledCSV()">
                        ğŸ“„ å¯¼å‡ºæ ‡ç­¾CSV
                    </button>
                    <button class="btn btn-save" onclick="app.exportImages()">
                        ğŸ–¼ï¸ å¯¼å‡ºå›¾åƒZIP
                    </button>
                </div>
            </div>

            <!-- è¿›åº¦ç»Ÿè®¡åŒº -->
            <div class="progress-section">
                <div class="progress-info">
                    <h3>ğŸ“ˆ æ ‡æ³¨è¿›åº¦</h3>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar">0%</div>
                    </div>
                </div>
                <div class="statistics">
                    <div class="stat-item">
                        <div class="label">æ€»çª—å£æ•°</div>
                        <div class="value" id="statTotal">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="label">å·²æ ‡æ³¨</div>
                        <div class="value" id="statLabeled">0</div>
                    </div>
                    <div class="stat-item up">
                        <div class="label">ğŸ“ˆ ä¸Šæ¶¨</div>
                        <div class="value" id="statUp">0</div>
                    </div>
                    <div class="stat-item down">
                        <div class="label">ğŸ“‰ ä¸‹è·Œ</div>
                        <div class="value" id="statDown">0</div>
                    </div>
                    <div class="stat-item fluctuation">
                        <div class="label">ğŸ“Š æ³¢åŠ¨</div>
                        <div class="value" id="statFluctuation">0</div>
                    </div>
                </div>
            </div>

            <!-- é”®ç›˜æç¤º -->
            <div class="keyboard-hint">
                ğŸ’¡ å¿«æ·é”®ï¼šâ† ä¸Šä¸€å¼  | â†’ ä¸‹ä¸€å¼  | 1 ä¸Šæ¶¨ | 2 ä¸‹è·Œ | 3 æ³¢åŠ¨ | S ä¿å­˜
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // å…¨å±€åº”ç”¨å¯¹è±¡
        // ========================================
        const app = {
            // æ•°æ®å­˜å‚¨
            rawData: [],              // åŸå§‹CSVæ•°æ®
            windows: [],              // æ»‘åŠ¨çª—å£æ•°ç»„
            annotations: [],          // æ ‡æ³¨æ•°æ®
            currentIndex: 0,          // å½“å‰çª—å£ç´¢å¼•
            fileName: '',             // åŸå§‹æ–‡ä»¶å
            hasUnsavedChanges: false, // æ˜¯å¦æœ‰æœªä¿å­˜çš„ä¿®æ”¹
            klineLabels: [],          // ä¸´æ—¶å­˜å‚¨Kçº¿æ ‡ç­¾ï¼ˆç”¨äºæ¢å¤æ ‡æ³¨ï¼‰

            // Canvaså…ƒç´ 
            canvasPrev: null,
            canvasCurrent: null,
            canvasNext: null,

            // Kçº¿å±•ç¤ºå›¾è¡¨
            klineChart: null,

            // Kçº¿å›¾ç¼©æ”¾çŠ¶æ€
            zoomState: {
                start: 0,
                end: 100
            },

            // åˆå§‹åŒ–
            init() {
                // æ·»åŠ  roundRect polyfillï¼ˆå…¼å®¹æ—§æµè§ˆå™¨ï¼‰
                if (!CanvasRenderingContext2D.prototype.roundRect) {
                    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                        if (w < 2 * r) r = w / 2;
                        if (h < 2 * r) r = h / 2;
                        this.moveTo(x + r, y);
                        this.arcTo(x + w, y, x + w, y + h, r);
                        this.arcTo(x + w, y + h, x, y + h, r);
                        this.arcTo(x, y + h, x, y, r);
                        this.arcTo(x, y, x + w, y, r);
                        this.closePath();
                        return this;
                    };
                }

                this.canvasPrev = document.getElementById('canvasPrev');
                this.canvasCurrent = document.getElementById('canvasCurrent');
                this.canvasNext = document.getElementById('canvasNext');

                // åˆå§‹åŒ–Kçº¿å±•ç¤ºå›¾è¡¨
                this.initKlineChart();

                // ç»‘å®šæ–‡ä»¶ä¸Šä¼ äº‹ä»¶
                document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileUpload(e));

                // ç»‘å®šé”®ç›˜äº‹ä»¶
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
            },

            // åˆå§‹åŒ–Kçº¿å±•ç¤ºå›¾è¡¨ï¼ˆä»Kline_label.htmlæå–ï¼‰
            initKlineChart() {
                this.klineChart = echarts.init(document.getElementById('klineChart'));

                const option = {
                    animation: false,
                    backgroundColor: '#ffffff',
                    title: {
                        text: 'Kçº¿æ•°æ®å±•ç¤º',
                        left: 'center',
                        textStyle: {
                            color: '#667eea',
                            fontSize: 16,
                            fontWeight: 'bold'
                        }
                    },
                    legend: {
                        bottom: 15,
                        left: 'center',
                        data: ['Kçº¿'],
                        textStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        borderWidth: 1,
                        borderColor: '#ccc',
                        padding: 15,
                        textStyle: {
                            color: '#000',
                            fontSize: 13
                        },
                        position: function (pos, params, el, elRect, size) {
                            const obj = {top: 10};
                            obj[['left', 'right'][+(pos[0] < size.viewSize[0] / 2)]] = 30;
                            return obj;
                        },
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        extraCssText: 'box-shadow: 0 4px 15px rgba(0,0,0,0.2); border-radius: 8px;'
                    },
                    axisPointer: {
                        link: [{xAxisIndex: 'all'}],
                        label: {
                            backgroundColor: '#667eea'
                        }
                    },
                    toolbox: {
                        feature: {
                            dataZoom: {
                                yAxisIndex: false
                            },
                            brush: {
                                type: ['lineX', 'clear']
                            },
                            saveAsImage: {
                                title: 'ä¿å­˜ä¸ºå›¾ç‰‡',
                                pixelRatio: 2
                            }
                        },
                        right: 20,
                        top: 10
                    },
                    grid: {
                        left: '3%',
                        right: '2%',
                        top: '10%',
                        bottom: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: [],
                        boundaryGap: true,
                        axisLine: {
                            onZero: false,
                            lineStyle: {
                                color: '#667eea'
                            }
                        },
                        splitLine: {show: false},
                        axisLabel: {
                            show: true,
                            rotate: 0,  // æ°´å¹³æ˜¾ç¤ºï¼Œä¸æ—‹è½¬
                            fontSize: 11,
                            showMaxLabel: true,
                            showMinLabel: true,
                            formatter: function(value, index) {
                                // åªè¿”å›å€¼ï¼Œintervalä¼šåœ¨renderKlineChartä¸­åŠ¨æ€è®¾ç½®
                                return value;
                            }
                        },
                        axisTick: {
                            alignWithLabel: true
                        },
                        axisPointer: {
                            z: 100
                        }
                    },
                    yAxis: {
                        scale: true,
                        splitArea: {
                            show: true
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#667eea'
                            }
                        }
                    },
                    dataZoom: [
                        {
                            type: 'inside',
                            start: 0,
                            end: 100
                        },
                        {
                            show: true,
                            type: 'slider',
                            bottom: '5%',
                            start: 0,
                            end: 100,
                            handleStyle: {
                                color: '#667eea'
                            },
                            dataBackground: {
                                areaStyle: {
                                    color: '#e3f2fd'
                                },
                                lineStyle: {
                                    color: '#2196F3'
                                }
                            }
                        }
                    ],
                    series: [
                        {
                            name: 'Kçº¿',
                            type: 'candlestick',
                            data: [],
                            barMaxWidth: 10,
                            itemStyle: {
                                color: '#26a69a',      // é˜³çº¿ï¼ˆä¸Šæ¶¨ï¼‰- ç»¿è‰²
                                color0: '#ef5350',     // é˜´çº¿ï¼ˆä¸‹è·Œï¼‰- çº¢è‰²
                                borderColor: '#26a69a',
                                borderColor0: '#ef5350',
                                borderWidth: 2
                            }
                        }
                    ]
                };

                this.klineChart.setOption(option);

                // ç›‘å¬dataZoomäº‹ä»¶ï¼Œä¿å­˜ç”¨æˆ·çš„ç¼©æ”¾çŠ¶æ€
                this.klineChart.on('datazoom', (params) => {
                    const option = this.klineChart.getOption();
                    if (option.dataZoom && option.dataZoom.length > 0) {
                        // ä¿å­˜å½“å‰ç¼©æ”¾çŠ¶æ€
                        this.zoomState.start = option.dataZoom[0].start;
                        this.zoomState.end = option.dataZoom[0].end;
                        console.log('ç¼©æ”¾çŠ¶æ€å·²æ›´æ–°:', this.zoomState);
                    }
                });
            },

            // ========================================
            // æ•°æ®å¤„ç†æ¨¡å—
            // ========================================

            // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
            handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.fileName = file.name;
                const reader = new FileReader();

                reader.onload = (e) => {
                    const csvText = e.target.result;
                    this.parseCSV(csvText);
                };

                reader.readAsText(file);
                document.getElementById('fileInfo').textContent = `æ­£åœ¨åŠ è½½: ${file.name}`;
            },

            // è§£æCSV
            parseCSV(csvText) {
                // ç§»é™¤BOMï¼ˆå­—èŠ‚é¡ºåºæ ‡è®°ï¼‰- å¯èƒ½å¯¼è‡´ç¬¬ä¸€ä¸ªå­—æ®µæ— æ³•è¯†åˆ«
                if (csvText.charCodeAt(0) === 0xFEFF) {
                    csvText = csvText.slice(1);
                    console.log('âš ï¸ æ£€æµ‹åˆ°å¹¶ç§»é™¤äº†BOMæ ‡è®°');
                }

                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    alert('CSVæ–‡ä»¶æ ¼å¼é”™è¯¯ï¼');
                    return;
                }

                // è§£æè¡¨å¤´
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

                // è°ƒè¯•ï¼šè¾“å‡ºè¡¨å¤´ä¿¡æ¯
                console.log('========== CSVè¡¨å¤´è°ƒè¯• ==========');
                console.log('åŸå§‹ç¬¬ä¸€è¡Œ:', lines[0]);
                console.log('è§£æåè¡¨å¤´:', headers);
                console.log('è¡¨å¤´æ•°é‡:', headers.length);
                console.log('æ˜¯å¦åŒ…å«time:', headers.includes('time'));
                console.log('æ˜¯å¦åŒ…å«timestamp:', headers.includes('timestamp'));

                // æ£€æŸ¥æ—¶é—´å­—æ®µï¼ˆæ”¯æŒ time æˆ– timestampï¼‰
                const timeField = headers.includes('time') ? 'time' :
                                 headers.includes('timestamp') ? 'timestamp' : null;

                if (!timeField) {
                    alert(`CSVç¼ºå°‘æ—¶é—´å­—æ®µï¼éœ€è¦ "time" æˆ– "timestamp" åˆ—\n\nå½“å‰è¡¨å¤´: ${headers.join(', ')}\n\nè¯·æ£€æŸ¥CSVæ–‡ä»¶æ ¼å¼ï¼`);
                    return;
                }

                // å¿…éœ€å­—æ®µï¼ˆé™¤äº†æ—¶é—´å­—æ®µï¼‰
                const requiredFields = ['open', 'high', 'low', 'close', 'volume'];

                // æ£€æŸ¥å¿…éœ€å­—æ®µ
                const missingFields = requiredFields.filter(field => !headers.includes(field));
                if (missingFields.length > 0) {
                    alert(`CSVç¼ºå°‘å¿…éœ€å­—æ®µ: ${missingFields.join(', ')}`);
                    return;
                }

                // è·å–å­—æ®µç´¢å¼•
                const indices = {
                    time: headers.indexOf(timeField)
                };
                requiredFields.forEach(field => {
                    indices[field] = headers.indexOf(field);
                });

                // æ£€æµ‹labelåˆ—ï¼ˆç”¨äºæ¢å¤æ ‡æ³¨ï¼‰
                const labelIndex = headers.indexOf('label');
                const hasLabelColumn = labelIndex !== -1;

                // è¾“å‡ºå­—æ®µæ˜ å°„ä¿¡æ¯
                console.log('========== CSVè§£æå¼€å§‹ ==========');
                console.log('CSVè¡¨å¤´:', headers);
                console.log('å­—æ®µç´¢å¼•æ˜ å°„:', indices);
                console.log('æ—¶é—´å­—æ®µ:', timeField);
                console.log('åŒ…å«labelåˆ—:', hasLabelColumn);

                // è§£ææ•°æ®è¡Œ
                this.rawData = [];
                this.klineLabels = [];  // é‡ç½®æ ‡ç­¾æ•°ç»„
                let invalidCount = 0;

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length < headers.length) continue;

                    // è§£æå¹¶éªŒè¯æ•°æ®ï¼ˆæ”¯æŒç§‘å­¦è®¡æ•°æ³•ï¼‰
                    const openStr = values[indices.open].trim();
                    const highStr = values[indices.high].trim();
                    const lowStr = values[indices.low].trim();
                    const closeStr = values[indices.close].trim();
                    const volumeStr = values[indices.volume].trim();

                    const open = parseFloat(openStr);
                    const high = parseFloat(highStr);
                    const low = parseFloat(lowStr);
                    const close = parseFloat(closeStr);
                    const volume = parseFloat(volumeStr);

                    // è°ƒè¯•å‰å‡ è¡Œçš„è§£æç»“æœ
                    if (i <= 3) {
                        console.log(`ç¬¬${i}è¡Œè§£æ:`, {
                            åŸå§‹: { open: openStr, high: highStr, low: lowStr, close: closeStr },
                            è§£æ: { open, high, low, close }
                        });
                    }

                    // æ£€æŸ¥æ•°æ®æœ‰æ•ˆæ€§
                    if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close) || isNaN(volume)) {
                        invalidCount++;
                        continue; // è·³è¿‡æ— æ•ˆè¡Œ
                    }

                    // æ£€æŸ¥æ•°æ®åˆç†æ€§ï¼ˆä»·æ ¼å¿…é¡»ä¸ºæ­£æ•°ï¼‰
                    if (open <= 0 || high <= 0 || low <= 0 || close <= 0 || volume < 0) {
                        invalidCount++;
                        continue;
                    }

                    // è‡ªåŠ¨ä¿®æ­£ä»·æ ¼é€»è¾‘é”™è¯¯ï¼ˆå¦‚æœ low > highï¼Œåˆ™äº¤æ¢å®ƒä»¬ï¼‰
                    let correctedHigh = high;
                    let correctedLow = low;
                    if (low > high) {
                        console.warn(`âš ï¸ ç¬¬${i+1}è¡Œæ•°æ®å¼‚å¸¸: low(${low}) > high(${high})ï¼Œå·²è‡ªåŠ¨äº¤æ¢`);
                        correctedHigh = low;
                        correctedLow = high;
                        invalidCount++;
                    }

                    // ç¡®ä¿ open å’Œ close åœ¨åˆç†èŒƒå›´å†…
                    const actualHigh = Math.max(correctedHigh, open, close);
                    const actualLow = Math.min(correctedLow, open, close);

                    this.rawData.push({
                        timestamp: values[indices.time].trim(),
                        open: open,
                        high: actualHigh,
                        low: actualLow,
                        close: close,
                        volume: volume
                    });

                    // æå–labelï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    if (hasLabelColumn && values.length > labelIndex) {
                        const label = values[labelIndex].trim();
                        this.klineLabels.push(label || null);
                    } else {
                        this.klineLabels.push(null);
                    }
                }

                // æ˜¾ç¤ºæ•°æ®è´¨é‡ä¿¡æ¯
                if (invalidCount > 0) {
                    console.warn(`âš ï¸ è·³è¿‡äº† ${invalidCount} è¡Œæ— ï¿½ï¿½ï¿½/å¼‚å¸¸æ•°æ®`);
                    document.getElementById('fileInfo').textContent =
                        `âš ï¸ è­¦å‘Š: è·³è¿‡äº† ${invalidCount} è¡Œæ— æ•ˆæ•°æ®ï¼ŒæˆåŠŸåŠ è½½ ${this.rawData.length} è¡Œ`;
                }

                console.log('========== CSVè§£æå®Œæˆ ==========');
                console.log(`âœ… æœ‰æ•ˆæ•°æ®: ${this.rawData.length} è¡Œ`);
                console.log(`âš ï¸ æ— æ•ˆæ•°æ®: ${invalidCount} è¡Œ`);
                console.log('å‰3æ ¹Kçº¿æ•°æ®:', this.rawData.slice(0, 3));

                // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æœ‰æ•ˆæ•°æ®
                if (this.rawData.length < 24) {
                    alert(`æœ‰æ•ˆæ•°æ®ä¸è¶³ï¼éœ€è¦è‡³å°‘24æ ¹Kçº¿ï¼Œå½“å‰ä»…æœ‰ ${this.rawData.length} æ ¹ã€‚`);
                    return;
                }

                // åˆ›å»ºæ»‘åŠ¨çª—å£
                this.createWindows();
            },

            // åˆ›å»ºæ»‘åŠ¨çª—å£
            createWindows() {
                const windowSize = 24;
                this.windows = [];
                this.annotations = [];

                for (let i = 0; i <= this.rawData.length - windowSize; i++) {
                    const window = this.rawData.slice(i, i + windowSize);
                    const normalized = this.normalizeWindow(window);

                    this.windows.push({
                        index: i,
                        raw: window,
                        normalized: normalized
                    });

                    // æ¢å¤æ ‡æ³¨ï¼šä½¿ç”¨çª—å£æœ€å³ä¾§Kçº¿ï¼ˆç¬¬i+23æ ¹ï¼‰çš„æ ‡ç­¾
                    let restoredLabel = null;
                    if (this.klineLabels && this.klineLabels.length > 0) {
                        const rightmostKlineIdx = i + 23;
                        if (rightmostKlineIdx < this.klineLabels.length) {
                            const label = this.klineLabels[rightmostKlineIdx];
                            // åªæ¢å¤æœ‰æ•ˆçš„æ ‡ç­¾ï¼ˆ'up', 'down', 'fluctuation'ï¼‰
                            if (label === 'up' || label === 'down' || label === 'fluctuation') {
                                restoredLabel = label;
                            }
                        }
                    }

                    this.annotations.push({
                        index: i,
                        label: restoredLabel
                    });
                }

                if (this.windows.length === 0) {
                    alert('æ•°æ®é‡ä¸è¶³24æ ¹Kçº¿ï¼Œæ— æ³•åˆ›å»ºçª—å£ï¼');
                    return;
                }

                // æ˜¾ç¤ºä¸»å†…å®¹åŒº
                document.getElementById('mainContent').classList.remove('hidden');

                // ç»Ÿè®¡æ¢å¤çš„æ ‡æ³¨æ•°é‡
                const restoredCount = this.annotations.filter(ann => ann.label).length;
                if (restoredCount > 0) {
                    document.getElementById('fileInfo').textContent =
                        `âœ… åŠ è½½æˆåŠŸ: ${this.rawData.length} æ ¹Kçº¿ï¼Œç”Ÿæˆ ${this.windows.length} ä¸ªçª—å£ | æ¢å¤äº† ${restoredCount} ä¸ªæ ‡æ³¨`;
                } else {
                    document.getElementById('fileInfo').textContent =
                        `âœ… åŠ è½½æˆåŠŸ: ${this.rawData.length} æ ¹Kçº¿ï¼Œç”Ÿæˆ ${this.windows.length} ä¸ªçª—å£`;
                }

                // è‡ªåŠ¨è·³è½¬åˆ°ç¬¬ä¸€ä¸ªæœªæ ‡æ³¨çª—å£
                this.currentIndex = this.findFirstUnlabeledIndex();
                this.updateUI();
            },

            // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæœªæ ‡æ³¨çª—å£çš„ç´¢å¼•
            findFirstUnlabeledIndex() {
                for (let i = 0; i < this.annotations.length; i++) {
                    if (!this.annotations[i].label) {
                        return i;
                    }
                }
                // å…¨éƒ¨å·²æ ‡æ³¨ï¼Œè¿”å›æœ€åä¸€ä¸ª
                return this.annotations.length - 1;
            },

            // å½’ä¸€åŒ–çª—å£æ•°æ®
            normalizeWindow(window) {
                // æ‰¾åˆ°ä»·æ ¼å’Œæˆäº¤é‡çš„èŒƒå›´
                let minPrice = Infinity;
                let maxPrice = -Infinity;
                let minVolume = Infinity;
                let maxVolume = -Infinity;

                window.forEach(candle => {
                    // è¿‡æ»¤æ— æ•ˆæ•°æ®
                    if (isNaN(candle.low) || isNaN(candle.high) ||
                        !isFinite(candle.low) || !isFinite(candle.high)) {
                        return;
                    }
                    minPrice = Math.min(minPrice, candle.low);
                    maxPrice = Math.max(maxPrice, candle.high);
                    minVolume = Math.min(minVolume, candle.volume);
                    maxVolume = Math.max(maxVolume, candle.volume);
                });

                // å¤„ç†æ— æ•ˆèŒƒå›´ï¼ˆå…¨éƒ¨æ•°æ®æ— æ•ˆæˆ–èŒƒå›´ä¸º0ï¼‰
                const priceRange = maxPrice - minPrice;
                const volumeRange = maxVolume - minVolume;
                const hasValidPrice = isFinite(priceRange) && priceRange > 0;
                const hasValidVolume = isFinite(volumeRange) && volumeRange > 0;

                // å½’ä¸€åŒ–
                return window.map(candle => ({
                    timestamp: candle.timestamp,
                    open: hasValidPrice ? (candle.open - minPrice) / priceRange : 0.5,
                    high: hasValidPrice ? (candle.high - minPrice) / priceRange : 1.0,
                    low: hasValidPrice ? (candle.low - minPrice) / priceRange : 0.0,
                    close: hasValidPrice ? (candle.close - minPrice) / priceRange : 0.5,
                    volume: hasValidVolume ? (candle.volume - minVolume) / volumeRange : 0.5,
                    isUp: candle.close >= candle.open
                }));
            },

            // ========================================
            // Canvasæ¸²æŸ“æ¨¡å—
            // ========================================

            // æ¸²æŸ“Kçº¿å±•ç¤ºå›¾è¡¨ï¼ˆå®Œå…¨é‡‡ç”¨Kline_label.htmlçš„é€»è¾‘ï¼Œåªæ˜¾ç¤ºKçº¿ï¼‰
            renderKlineChart() {
                const dates = this.rawData.map(item => item.timestamp);
                const values = this.rawData.map(item => [item.open, item.close, item.low, item.high]);

                // ç”Ÿæˆå½“å‰çª—å£é«˜äº®æ ‡è®°
                const windowStart = this.currentIndex;
                const windowEnd = this.currentIndex + 23;

                // åŠ¨æ€è®¡ç®—æ—¶é—´è½´æ ‡ç­¾é—´éš”ï¼Œç¡®ä¿ç¨€ç–æ˜¾ç¤ºï¼ˆå‚è€ƒå›¾2æ ·å¼ï¼‰
                const totalLabels = this.rawData.length;
                const targetLabels = 8;  // ç›®æ ‡æ˜¾ç¤ºçº¦8ä¸ªæ—¶é—´æ ‡ç­¾
                const labelInterval = Math.max(Math.floor(totalLabels / targetLabels), 1);

                this.klineChart.setOption({
                    title: {
                        text: `Kçº¿æ•°æ®å±•ç¤ºï¼ˆå…±${this.rawData.length}æ ¹ | å½“å‰çª—å£: ç¬¬${windowStart+1}-${windowEnd+1}æ ¹ï¼‰`,
                        left: 'center',
                        textStyle: {
                            color: '#667eea',
                            fontSize: 16,
                            fontWeight: 'bold'
                        }
                    },
                    xAxis: {
                        data: dates,
                        axisLabel: {
                            interval: labelInterval,  // åŠ¨æ€é—´éš”
                            rotate: 0,  // æ°´å¹³æ˜¾ç¤º
                            fontSize: 11,
                            showMaxLabel: true,
                            showMinLabel: true
                        }
                    },
                    dataZoom: [
                        {
                            type: 'inside',
                            start: this.zoomState.start,
                            end: this.zoomState.end
                        },
                        {
                            show: true,
                            type: 'slider',
                            bottom: '5%',
                            start: this.zoomState.start,
                            end: this.zoomState.end
                        }
                    ],
                    series: [
                        {
                            data: values,
                            markArea: {
                                silent: false,
                                itemStyle: {
                                    color: 'rgba(255, 193, 7, 0.2)'
                                },
                                label: {
                                    show: true,
                                    position: 'top',
                                    formatter: 'å½“å‰æ ‡æ³¨çª—å£',
                                    fontSize: 12,
                                    color: '#ff9800'
                                },
                                data: [[
                                    {xAxis: windowStart},
                                    {xAxis: windowEnd}
                                ]]
                            }
                        }
                    ],
                    tooltip: {
                        formatter: (params) => {
                            if (params.length === 0) return '';

                            let result = '';
                            params.forEach(param => {
                                if (param.seriesName === 'Kçº¿') {
                                    const index = param.dataIndex;
                                    const data = this.rawData[index];
                                    const change = ((data.close - data.open) / data.open * 100).toFixed(2);
                                    const changeColor = change >= 0 ? '#26a69a' : '#ef5350';  // ç»¿æ¶¨çº¢è·Œ

                                    // åˆ¤æ–­æ˜¯å¦åœ¨å½“å‰æ ‡æ³¨çª—å£
                                    const inWindow = index >= windowStart && index <= windowEnd;
                                    const windowTag = inWindow ? '<span style="background: #ff9800; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-left: 8px;">å½“å‰çª—å£</span>' : '';

                                    result += `<div style="font-weight: bold; margin-bottom: 10px; font-size: 14px; border-bottom: 2px solid #eee; padding-bottom: 5px;">${data.timestamp}${windowTag}</div>`;
                                    result += `<div style="display: grid; grid-template-columns: 80px 1fr; gap: 8px; font-size: 13px;">`;
                                    result += `<div style="color: #999;">å¼€ç›˜:</div><div style="font-weight: 600;">${data.open.toFixed(8)}</div>`;
                                    result += `<div style="color: #999;">æ”¶ç›˜:</div><div style="font-weight: 600;">${data.close.toFixed(8)}</div>`;
                                    result += `<div style="color: #999;">æœ€é«˜:</div><div style="font-weight: 600; color: #f44336;">${data.high.toFixed(8)}</div>`;
                                    result += `<div style="color: #999;">æœ€ä½:</div><div style="font-weight: 600; color: #26a69a;">${data.low.toFixed(8)}</div>`;
                                    result += `<div style="color: #999;">æ¶¨è·Œå¹…:</div><div style="font-weight: 600; color: ${changeColor};">${change}%</div>`;
                                    result += `<div style="color: #999;">æˆäº¤é‡:</div><div style="font-weight: 600;">${data.volume.toLocaleString()}</div>`;
                                    result += `</div>`;
                                }
                            });

                            return result;
                        }
                    }
                });

                // å¼ºåˆ¶é‡ç»˜å›¾è¡¨ï¼Œç¡®ä¿å¸ƒå±€æ­£ç¡®
                this.klineChart.resize();
            },

            // ç»˜åˆ¶Kçº¿å›¾ï¼ˆå½’ä¸€åŒ–ï¼‰
            drawKlineChart(canvas, normalizedData, label = null) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = 20;
                const chartWidth = width - 2 * padding;
                const chartHeight = height - 2 * padding;

                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, width, height);

                // ç»˜åˆ¶èƒŒæ™¯
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);

                // æ ¹æ®æ ‡ç­¾ç»˜åˆ¶è¾¹æ¡†
                if (label) {
                    ctx.strokeStyle = label === 'up' ? '#11998e' :
                                     label === 'down' ? '#eb3349' : '#f5576c';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(0, 0, width, height);

                    // ç»˜åˆ¶æ ‡ç­¾æ ‡è®°
                    this.drawLabelTag(ctx, label, width);
                }

                // ç»˜åˆ¶ç½‘æ ¼
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (chartHeight / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }

                // ç»˜åˆ¶Kçº¿
                const candleWidth = chartWidth / normalizedData.length;
                const candleSpacing = candleWidth * 0.2;
                const actualCandleWidth = candleWidth - candleSpacing;

                normalizedData.forEach((candle, index) => {
                    const x = padding + index * candleWidth + candleSpacing / 2;
                    this.drawCandlestick(ctx, x, padding, candle, actualCandleWidth, chartHeight);
                });

                // ç»˜åˆ¶åæ ‡è½´æ ‡ç­¾
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (chartHeight / 4) * i;
                    const value = (1 - i * 0.25).toFixed(2);
                    ctx.fillText(value, padding - 5, y + 4);
                }
            },

            // ç»˜åˆ¶å•æ ¹Kçº¿
            drawCandlestick(ctx, x, padding, candle, width, chartHeight) {
                const centerX = x + width / 2;

                // è®¡ç®—Yåæ ‡ï¼ˆæ³¨æ„Yè½´æ˜¯åçš„ï¼‰
                const highY = padding + (1 - candle.high) * chartHeight;
                const lowY = padding + (1 - candle.low) * chartHeight;
                const openY = padding + (1 - candle.open) * chartHeight;
                const closeY = padding + (1 - candle.close) * chartHeight;

                // ç»˜åˆ¶ä¸Šä¸‹å½±çº¿
                ctx.strokeStyle = candle.isUp ? '#11998e' : '#eb3349';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX, highY);
                ctx.lineTo(centerX, lowY);
                ctx.stroke();

                // ç»˜åˆ¶Kçº¿å®ä½“
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.abs(closeY - openY);

                if (candle.isUp) {
                    // é˜³çº¿ - ç»¿è‰²å®å¿ƒ
                    ctx.fillStyle = '#11998e';
                    ctx.fillRect(x, bodyTop, width, Math.max(bodyHeight, 1));
                } else {
                    // é˜´çº¿ - çº¢è‰²ç©ºå¿ƒ
                    ctx.fillStyle = '#eb3349';
                    ctx.fillRect(x, bodyTop, width, Math.max(bodyHeight, 1));
                }
            },

            // ç»˜åˆ¶æ ‡ç­¾æ ‡è®°
            drawLabelTag(ctx, label, canvasWidth) {
                const labelConfig = {
                    'up': { text: 'ä¸Šæ¶¨', bgColor: 'rgba(17, 153, 142, 0.9)', emoji: 'ğŸ“ˆ' },
                    'down': { text: 'ä¸‹è·Œ', bgColor: 'rgba(235, 51, 73, 0.9)', emoji: 'ğŸ“‰' },
                    'fluctuation': { text: 'æ³¢åŠ¨', bgColor: 'rgba(245, 87, 108, 0.9)', emoji: 'ğŸ“Š' }
                };

                const config = labelConfig[label];
                if (!config) return;

                const text = `${config.emoji} ${config.text}`;

                // è®¾ç½®å­—ä½“ä»¥è®¡ç®—æ–‡æœ¬å®½åº¦
                ctx.font = 'bold 14px Arial';
                const textWidth = ctx.measureText(text).width;

                // æ ‡ç­¾å°ºå¯¸å’Œä½ç½®
                const tagPadding = 8;
                const tagHeight = 24;
                const tagWidth = textWidth + tagPadding * 2;
                const tagX = canvasWidth - tagWidth - 10;
                const tagY = 10;

                // ç»˜åˆ¶èƒŒæ™¯åœ†è§’çŸ©å½¢
                ctx.fillStyle = config.bgColor;
                ctx.beginPath();
                ctx.roundRect(tagX, tagY, tagWidth, tagHeight, 4);
                ctx.fill();

                // ç»˜åˆ¶æ–‡æœ¬
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, tagX + tagWidth / 2, tagY + tagHeight / 2);
            },

            // ========================================
            // UIæ§åˆ¶æ¨¡å—
            // ========================================

            // æ›´æ–°UI
            updateUI() {
                // æ¸²æŸ“Kçº¿å±•ç¤ºå›¾è¡¨ï¼ˆæ˜¾ç¤ºæ‰€æœ‰æ•°æ®ï¼Œé«˜äº®å½“å‰çª—å£ï¼‰
                this.renderKlineChart();

                // æ¸²æŸ“ä¸‰å¼ å½’ä¸€åŒ–å›¾
                const prevIndex = this.currentIndex - 1;
                const nextIndex = this.currentIndex + 1;

                // ä¸Šä¸€å¼ 
                if (prevIndex >= 0) {
                    const prevLabel = this.annotations[prevIndex].label;
                    this.drawKlineChart(this.canvasPrev, this.windows[prevIndex].normalized, prevLabel);
                } else {
                    this.clearCanvas(this.canvasPrev);
                }

                // å½“å‰å¼ 
                const currentLabel = this.annotations[this.currentIndex].label;
                this.drawKlineChart(this.canvasCurrent, this.windows[this.currentIndex].normalized, currentLabel);

                // ä¸‹ä¸€å¼ 
                if (nextIndex < this.windows.length) {
                    const nextLabel = this.annotations[nextIndex].label;
                    this.drawKlineChart(this.canvasNext, this.windows[nextIndex].normalized, nextLabel);
                } else {
                    this.clearCanvas(this.canvasNext);
                }

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                document.getElementById('btnPrev').disabled = this.currentIndex === 0;
                document.getElementById('btnNext').disabled = this.currentIndex === this.windows.length - 1;

                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                this.updateStatistics();
            },

            // æ¸…ç©ºç”»å¸ƒ
            clearCanvas(canvas) {
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ccc';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ— æ•°æ®', canvas.width / 2, canvas.height / 2);
            },

            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            updateStatistics() {
                const stats = this.getStatistics();

                document.getElementById('statTotal').textContent = stats.total;
                document.getElementById('statLabeled').textContent = stats.labeled;
                document.getElementById('statUp').textContent = stats.up;
                document.getElementById('statDown').textContent = stats.down;
                document.getElementById('statFluctuation').textContent = stats.fluctuation;

                // æ›´æ–°è¿›åº¦æ¡
                const percentage = stats.total > 0 ? Math.round((stats.labeled / stats.total) * 100) : 0;
                const progressBar = document.getElementById('progressBar');
                progressBar.style.width = percentage + '%';
                progressBar.textContent = percentage + '%';
            },

            // è·å–ç»Ÿè®¡ä¿¡æ¯
            getStatistics() {
                const total = this.annotations.length;
                let labeled = 0;
                let up = 0;
                let down = 0;
                let fluctuation = 0;

                this.annotations.forEach(ann => {
                    if (ann.label) {
                        labeled++;
                        if (ann.label === 'up') up++;
                        else if (ann.label === 'down') down++;
                        else if (ann.label === 'fluctuation') fluctuation++;
                    }
                });

                return { total, labeled, up, down, fluctuation };
            },

            // ========================================
            // æ ‡æ³¨ç®¡ç†æ¨¡å—
            // ========================================

            // è®¾ç½®æ ‡ç­¾
            setLabel(label) {
                this.annotations[this.currentIndex].label = label;

                // æ ‡è®°æ•°æ®å·²ä¿®æ”¹ï¼ˆç”¨äºæç¤ºç”¨æˆ·ä¿å­˜ï¼‰
                this.hasUnsavedChanges = true;

                // è‡ªåŠ¨è·³è½¬åˆ°ä¸‹ä¸€å¼ 
                if (this.currentIndex < this.windows.length - 1) {
                    // è®¡ç®—å¹³ç§»é‡ï¼šå‘å³ç§»åŠ¨ä¸€ä¸ªKçº¿ï¼ˆè§†è§‰ä¸Šå›¾è¡¨å‘å·¦ç§»åŠ¨ï¼‰
                    const shiftPercent = 100 / this.rawData.length;

                    // æ›´æ–°ç¼©æ”¾çŠ¶æ€ï¼Œä¿æŒèŒƒå›´ä¸å˜
                    const newStart = this.zoomState.start + shiftPercent;
                    const newEnd = this.zoomState.end + shiftPercent;

                    // ç¡®ä¿ä¸è¶…å‡ºè¾¹ç•Œ
                    if (newEnd <= 100) {
                        this.zoomState.start = newStart;
                        this.zoomState.end = newEnd;
                    }

                    this.nextPage();
                } else {
                    // å·²ç»æ˜¯æœ€åä¸€å¼ ï¼Œåªæ›´æ–°UI
                    this.updateUI();
                }
            },

            // ä¸‹ä¸€é¡µ
            nextPage() {
                if (this.currentIndex < this.windows.length - 1) {
                    this.currentIndex++;
                    this.updateUI();
                }
            },

            // ä¸Šä¸€é¡µ
            prevPage() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.updateUI();
                }
            },

            // è·³è½¬åˆ°æŒ‡å®šé¡µ
            goToIndex(index) {
                if (index >= 0 && index < this.windows.length) {
                    this.currentIndex = index;
                    this.updateUI();
                }
            },

            // ä¿å­˜ä¸ºCSV
            saveToCSV() {
                // è·å–ç»Ÿè®¡ä¿¡æ¯
                const stats = this.getStatistics();

                // æ„å»ºCSVå†…å®¹
                let csv = 'window_index,label';

                // æ·»åŠ 24æ ¹Kçº¿çš„åˆ—å
                for (let i = 0; i < 24; i++) {
                    csv += `,time_${i},open_${i},high_${i},low_${i},close_${i},volume_${i}`;
                }
                csv += '\n';

                // æ·»åŠ æ•°æ®è¡Œ
                this.annotations.forEach((ann, idx) => {
                    const window = this.windows[idx];
                    csv += `${ann.index},${ann.label || ''}`;

                    window.raw.forEach(candle => {
                        csv += `,${candle.timestamp},${candle.open},${candle.high},${candle.low},${candle.close},${candle.volume}`;
                    });

                    csv += '\n';
                });

                // ä¸‹è½½æ–‡ä»¶
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);

                link.setAttribute('href', url);
                link.setAttribute('download', `annotated_${this.fileName}`);
                link.style.visibility = 'hidden';

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // æ ‡è®°ä¸ºå·²ä¿å­˜
                this.hasUnsavedChanges = false;

                // æ˜¾ç¤ºä¿å­˜æˆåŠŸæç¤º
                const percentage = stats.total > 0 ? Math.round((stats.labeled / stats.total) * 100) : 0;
                alert(`âœ… ä¿å­˜æˆåŠŸï¼\n\n` +
                      `æ€»çª—å£æ•°: ${stats.total}\n` +
                      `å·²æ ‡æ³¨: ${stats.labeled} (${percentage}%)\n` +
                      `ä¸Šæ¶¨: ${stats.up} | ä¸‹è·Œ: ${stats.down} | æ³¢åŠ¨: ${stats.fluctuation}\n\n` +
                      `æ–‡ä»¶å·²ä¸‹è½½: annotated_${this.fileName}`);
            },

            // ä¸‹è½½æ–‡ä»¶è¾…åŠ©å‡½æ•°
            downloadFile(content, filename, mimeType) {
                const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            },

            // å¯¼å‡ºå¸¦æ ‡ç­¾çš„åŸå§‹CSVï¼ˆç”¨äºæ¢å¤æ ‡æ³¨ï¼‰
            exportLabeledCSV() {
                // åˆ›å»ºä¸€ä¸ªæ˜ å°„ï¼šæ¯æ ¹Kçº¿å¯¹åº”çš„æ ‡ç­¾
                // æ ¹æ®ç”¨æˆ·é€‰æ‹©çš„è§„åˆ™ï¼šçª—å£içš„æ ‡ç­¾æ ‡è®°åœ¨ç¬¬i+23æ ¹Kçº¿ä¸Š
                const klineLabels = new Array(this.rawData.length).fill('');

                this.annotations.forEach((ann, windowIdx) => {
                    if (ann.label) {
                        const targetKlineIdx = windowIdx + 23;
                        if (targetKlineIdx < this.rawData.length) {
                            klineLabels[targetKlineIdx] = ann.label;
                        }
                    }
                });

                // æ„å»ºCSVï¼ˆä¸åŸå§‹æ ¼å¼ç›¸åŒï¼Œå¢åŠ labelåˆ—ï¼‰
                let csv = 'timestamp,open,high,low,close,volume,label\n';

                this.rawData.forEach((candle, idx) => {
                    csv += `${candle.timestamp},${candle.open},${candle.high},${candle.low},${candle.close},${candle.volume},${klineLabels[idx]}\n`;
                });

                // ä¸‹è½½æ–‡ä»¶
                this.downloadFile(csv, `labeled_${this.fileName}`, 'text/csv');

                // æ˜¾ç¤ºä¿å­˜æˆåŠŸæç¤º
                const labeledCount = klineLabels.filter(label => label !== '').length;
                alert(`âœ… å¯¼å‡ºæˆåŠŸï¼\n\n` +
                      `æ€»Kçº¿æ•°: ${this.rawData.length}\n` +
                      `å·²æ ‡æ³¨Kçº¿: ${labeledCount}\n\n` +
                      `æ–‡ä»¶å·²ä¸‹è½½: labeled_${this.fileName}\n\n` +
                      `ğŸ’¡ å¯ä»¥é‡æ–°å¯¼å…¥æ­¤æ–‡ä»¶ç»§ç»­æ ‡æ³¨ï¼`);
            },

            // å¯¼å‡ºå·²æ ‡æ³¨çš„å›¾åƒï¼ˆPyTorch ImageFolderæ ¼å¼ï¼Œç”¨äºè®­ç»ƒå›¾åƒåˆ†ç±»æ¨¡å‹ï¼‰
            async exportImages() {
                // æ£€æŸ¥JSZipæ˜¯å¦åŠ è½½æˆåŠŸ
                if (typeof JSZip === 'undefined') {
                    alert('âŒ JSZipåº“æœªåŠ è½½ï¼è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ·æ–°é¡µé¢ã€‚');
                    return;
                }

                // ç­›é€‰å·²æ ‡æ³¨çš„çª—å£
                const labeledAnnotations = this.annotations.filter(ann => ann.label);
                if (labeledAnnotations.length === 0) {
                    alert('âš ï¸ æ²¡æœ‰å·²æ ‡æ³¨çš„æ•°æ®ï¼\nè¯·å…ˆæ ‡æ³¨ä¸€äº›çª—å£å†å¯¼å‡ºå›¾åƒã€‚');
                    return;
                }

                // æ˜¾ç¤ºå¤„ç†æç¤º
                const processingMsg = `æ­£åœ¨ç”Ÿæˆ ${labeledAnnotations.length} å¼ å›¾åƒ...\nè¯·ç¨å€™ï¼Œä¸è¦å…³é—­é¡µé¢å–µï½`;
                console.log(processingMsg);

                try {
                    // åˆ›å»ºZIPæ–‡ä»¶
                    const zip = new JSZip();

                    // åˆ›å»ºæ•°æ®é›†æ ¹æ–‡ä»¶å¤¹
                    const datasetFolder = zip.folder('kline_dataset');
                    const imagesFolder = datasetFolder.folder('images');

                    // åˆ›å»ºä¸‰ä¸ªç±»åˆ«æ–‡ä»¶å¤¹ï¼ˆPyTorch ImageFolderæ ¼å¼ï¼‰
                    const folders = {
                        up: imagesFolder.folder('up'),
                        down: imagesFolder.folder('down'),
                        fluctuation: imagesFolder.folder('fluctuation')
                    };

                    // åˆ›å»ºä¸´æ—¶Canvasç”¨äºç»˜åˆ¶å¯¼å‡ºå›¾åƒ
                    const exportCanvas = document.createElement('canvas');
                    exportCanvas.width = 600;
                    exportCanvas.height = 400;

                    // å‡†å¤‡labels.csvçš„å†…å®¹ï¼ˆå¤‡ä»½ç”¨ï¼‰
                    let labelsCSV = 'filename,label\n';

                    // éå†æ‰€æœ‰å·²æ ‡æ³¨çª—å£
                    for (let i = 0; i < labeledAnnotations.length; i++) {
                        const ann = labeledAnnotations[i];
                        const window = this.windows[ann.index];

                        // ç”Ÿæˆæ–‡ä»¶åï¼šçª—å£ç´¢å¼•_æ—¶é—´æˆ³.png
                        const timestamp = window.raw[0].timestamp.replace(/[\/:\s]/g, '-');
                        const filename = `${ann.index}_${timestamp}.png`;

                        // ç»˜åˆ¶Kçº¿å›¾åˆ°ä¸´æ—¶Canvas
                        this.drawKlineChart(exportCanvas, window.normalized, ann.label);

                        // è½¬æ¢ä¸ºBlob
                        const blob = await new Promise(resolve => {
                            exportCanvas.toBlob(resolve, 'image/png');
                        });

                        // æ·»åŠ åˆ°å¯¹åº”æ ‡ç­¾æ–‡ä»¶å¤¹
                        folders[ann.label].file(filename, blob);

                        // è®°å½•åˆ°labels.csvï¼ˆä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼‰
                        labelsCSV += `images/${ann.label}/${filename},${ann.label}\n`;

                        // è¾“å‡ºè¿›åº¦
                        if ((i + 1) % 10 === 0 || (i + 1) === labeledAnnotations.length) {
                            console.log(`å·²å¤„ç† ${i + 1}/${labeledAnnotations.length} å¼ å›¾åƒ...`);
                        }
                    }

                    // å°†labels.csvæ·»åŠ åˆ°æ•°æ®é›†æ ¹ç›®å½•
                    datasetFolder.file('labels.csv', labelsCSV);

                    // ç”ŸæˆREADME.mdè¯´æ˜æ–‡ä»¶
                    const readmeContent = `# Kçº¿å›¾åƒåˆ†ç±»æ•°æ®é›†

## æ•°æ®é›†ç»“æ„
\`\`\`
kline_dataset/
â”œâ”€â”€ images/               # å›¾åƒæ–‡ä»¶å¤¹ï¼ˆPyTorch ImageFolderæ ¼å¼ï¼‰
â”‚   â”œâ”€â”€ up/              # ä¸Šæ¶¨ç±»åˆ«
â”‚   â”œâ”€â”€ down/            # ä¸‹è·Œç±»åˆ«
â”‚   â””â”€â”€ fluctuation/     # æ³¢åŠ¨ç±»åˆ«
â””â”€â”€ labels.csv           # æ ‡ç­¾æ–‡ä»¶ï¼ˆå¤‡ä»½ç”¨ï¼‰
\`\`\`

## æ•°æ®é›†ç»Ÿè®¡
- æ€»å›¾åƒæ•°: ${labeledAnnotations.length}
- ä¸Šæ¶¨(up): ${this.annotations.filter(a => a.label === 'up').length}
- ä¸‹è·Œ(down): ${this.annotations.filter(a => a.label === 'down').length}
- æ³¢åŠ¨(fluctuation): ${this.annotations.filter(a => a.label === 'fluctuation').length}

## å›¾åƒä¿¡æ¯
- å°ºå¯¸: 600x400 åƒç´ 
- æ ¼å¼: PNG
- å†…å®¹: 24æ ¹Kçº¿å½’ä¸€åŒ–å›¾åƒ
- å‘½å: {çª—å£ç´¢å¼•}_{æ—¶é—´æˆ³}.png

## ä½¿ç”¨æ–¹æ³•

### PyTorch
\`\`\`python
from torchvision import datasets, transforms
from torch.utils.data import DataLoader

# å®šä¹‰æ•°æ®è½¬æ¢
transform = transforms.Compose([
    transforms.Resize((224, 224)),  # è°ƒæ•´ä¸ºæ¨¡å‹è¾“å…¥å°ºå¯¸
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                       std=[0.229, 0.224, 0.225])
])

# åŠ è½½æ•°æ®é›†ï¼ˆä½¿ç”¨ImageFolderï¼‰
dataset = datasets.ImageFolder(root='kline_dataset/images',
                              transform=transform)

# åˆ›å»ºæ•°æ®åŠ è½½å™¨
dataloader = DataLoader(dataset, batch_size=32, shuffle=True)

# ç±»åˆ«æ˜ å°„
print(dataset.classes)  # ['down', 'fluctuation', 'up']
print(dataset.class_to_idx)  # {'down': 0, 'fluctuation': 1, 'up': 2}
\`\`\`

### TensorFlow/Keras
\`\`\`python
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# åˆ›å»ºæ•°æ®ç”Ÿæˆå™¨
datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2  # 80%è®­ç»ƒï¼Œ20%éªŒè¯
)

# è®­ç»ƒé›†
train_generator = datagen.flow_from_directory(
    'kline_dataset/images',
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    subset='training'
)

# éªŒè¯é›†
val_generator = datagen.flow_from_directory(
    'kline_dataset/images',
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    subset='validation'
)
\`\`\`

## ç”Ÿæˆæ—¶é—´
${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}

## æ ‡æ³¨æ¥æº
BNBUSDT Kçº¿æ•°æ®æ ‡æ³¨å·¥å…·
`;

                    datasetFolder.file('README.md', readmeContent);

                    // ç”ŸæˆZIPæ–‡ä»¶
                    console.log('æ­£åœ¨æ‰“åŒ…ZIPæ–‡ä»¶...');
                    const content = await zip.generateAsync({ type: 'blob' });

                    // ä¸‹è½½ZIP
                    const zipFilename = `kline_dataset_${Date.now()}.zip`;
                    this.downloadFile(content, zipFilename, 'application/zip');

                    // æ˜¾ç¤ºæˆåŠŸæç¤º
                    const stats = this.getStatistics();
                    alert(`âœ… å¯¼å‡ºæˆåŠŸï¼\n\n` +
                          `ğŸ“Š æ•°æ®é›†ç»Ÿè®¡ï¼š\n` +
                          `  æ€»å›¾åƒæ•°: ${labeledAnnotations.length}\n` +
                          `  ğŸ“ˆ ä¸Šæ¶¨: ${stats.up}\n` +
                          `  ğŸ“‰ ä¸‹è·Œ: ${stats.down}\n` +
                          `  ğŸ“Š æ³¢åŠ¨: ${stats.fluctuation}\n\n` +
                          `ğŸ“ æ•°æ®é›†ç»“æ„ï¼ˆPyTorch ImageFolderæ ¼å¼ï¼‰ï¼š\n` +
                          `  kline_dataset/\n` +
                          `  â”œâ”€â”€ images/up/\n` +
                          `  â”œâ”€â”€ images/down/\n` +
                          `  â”œâ”€â”€ images/fluctuation/\n` +
                          `  â”œâ”€â”€ labels.csv\n` +
                          `  â””â”€â”€ README.md\n\n` +
                          `æ–‡ä»¶å·²ä¸‹è½½: ${zipFilename}\n\n` +
                          `ğŸ’¡ è§£å‹åå¯ç›´æ¥ç”¨äºPyTorch/TensorFlowè®­ç»ƒï¼`);

                } catch (error) {
                    console.error('å¯¼å‡ºå›¾åƒå¤±è´¥:', error);
                    alert(`âŒ å¯¼å‡ºå¤±è´¥ï¼\n\né”™è¯¯ä¿¡æ¯: ${error.message}`);
                }
            },

            // ========================================
            // é”®ç›˜å¿«æ·é”®
            // ========================================

            handleKeyboard(event) {
                // åªåœ¨ä¸»å†…å®¹æ˜¾ç¤ºæ—¶å“åº”
                if (document.getElementById('mainContent').classList.contains('hidden')) {
                    return;
                }

                switch(event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        this.prevPage();
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        this.nextPage();
                        break;
                    case '1':
                        event.preventDefault();
                        this.setLabel('up');
                        break;
                    case '2':
                        event.preventDefault();
                        this.setLabel('down');
                        break;
                    case '3':
                        event.preventDefault();
                        this.setLabel('fluctuation');
                        break;
                    case 's':
                    case 'S':
                        event.preventDefault();
                        this.saveToCSV();
                        break;
                }
            }
        };

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            app.init();
        });

        // çª—å£å¤§å°æ”¹å˜æ—¶é‡ç»˜Kçº¿å›¾è¡¨
        window.addEventListener('resize', () => {
            if (app.klineChart) {
                app.klineChart.resize();
            }
        });
    </script>
</body>
</html>
